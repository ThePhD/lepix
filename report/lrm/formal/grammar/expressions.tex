\section{Expressions}
The following sections formalize the types of expressions that can be used in a \lepix{} program and also specify completely, the precedence of operators and left or right associativity.

\subsection{Primary Expression}
\begin{grammar}
	<primary_expression> ::= <identifier> 
	\alt <integer-constant>  
	\alt <float-constant> 
	\alt ( expression )
\end{grammar}
\begin{enumerate}
	\item A primary expression are composed of either a constant, an identifier, or an expression in enclosing parentheses.
\end{enumerate}

\subsection{Postfix Expressions}
\begin{grammar}
	<postfix_expression> ::= <primary_expression> 
	\alt <postfix_expresion> ( argument_list )
	\alt <postfix_expression> [ expression ]
	\alt <postfix_expression> . identifier
	<argument_list> ::= <>
	\alt <argument_list> , <postfix_expression>
\end{grammar}
\begin{enumerate}
	\item A postfix expression consist of primary expression followed by postfix operators. The operators in postfix expressions are left-associative.
\end{enumerate}

\subsubsection{Indexing}
\begin{enumerate}
	\item Array indexing consists of a postfix expression, followed by an expression enclosed in square brackets. The expression in the brackets must evaluate to an integer which will represent the index to be accessed.
	\item The value returned by indexing is the value in the array at the specified index.
\end{enumerate}

\subsubsection{Function Calls}
\begin{enumerate}
	\item A function call is a postfix expression (representing the name of a defined function) followed by a (possibly empty) list of arguments enclosed in parentheses.
	\item The argument list is represented as a comma separated list of postfix expressions.
\end{enumerate}

\subsubsection{Structure access}
\begin{enumerate}
	\item The name of a structure followed by a dot and an identifier name is a postfix expression. The expression's value is the named member's of the structure that is being accessed.
\end{enumerate}

\subsection{Unary Expression}
\begin{grammar}
	<unary_operator> ::= \~
	\alt !
	\alt -
	\alt *
	
	<unary_expression> ::= <unary_operator> <postfix_expression>
\end{grammar}
\begin{enumerate}
	\item A unary expression consists of <postfix_expression> preceded by a unary operator (-   ,$\tilde{}$ , !, * ,\&).
	\item Unary expressions are left-associative.
	\item The unary operation is carried out after the postfix expression has been evaluated.
\end{enumerate}



The function of each unary operator has been summarized in the table below:
\begin{center}
\begin{tabular}{ | c | c | } 
\hline
- & Unary minus\\
\hline
$\tilde{}$ & Bitwise negation operator\\
\hline
\textasciicircum{} & Logical negation operator\\
\hline
* & Indirection operator\\
\hline
\end{tabular}
\end{center}

\subsection{Casting}
The \lepix{} language supports the casting of an integer to a floating point value and vice versa. It also supports casting of an integer value to a boolean value and vice versa. Integer to float casting creates a floating point constant with the same value as the integer. Casting a floating point value to an integer rounds down to the nearest integral value. Casting a boolean value to an integer gives 1 if the value is true and 0 if it is false. Casting an integer to a boolean value yields false if the value is 0 and true otherwise. 

\begin{grammar}
<cast_expression> ::= <unary_expression>
\alt <unary_expression> as <type_name>
\end{grammar}

\subsection{Multiplicative Expressions}
The multiplication (*), division (/) and modulo (\%) operators are left associative.

\begin{grammar}
<multiplicative_expression> ::= <cast_expression>
\alt <multiplicative_expression> * <cast_expression>
\alt <multiplicative_expression> / <cast_expression>
\alt <multiplicative_expression> \% <cast_expression>
\end{grammar}

\subsection{Additive Expressions}
The addition (+) and subtraction  (-) operators are left associative.

\begin{grammar}
<additive_expression> ::= <multiplicative_expression>
\alt <additive_expression> + <cast_expression>
\alt <additive_expression> - <cast_expression>
\end{grammar}

\subsection{Relational Expressions}
The relational operators less than (<), greater than (>), less than or equal to (<=) and greater than or equal to (>=) are left associative. 

\begin{grammar}
<relational_expression> ::= <additive_expression>
\alt <relational_expression> < <additive_expression>
\alt <relational_expression> <= <additive_expression>
\alt <relational_expression> > <additive_expression>
\alt <relational_expression> >= <additive_expression>
\end{grammar}


\subsection{Equality Expression}
\begin{grammar}
	<equality_expression> ::= <relational_expression>
		\alt <equality_expression> != <relational_expression>
		\alt <equality_expression> == <relational_expression>
\end{grammar}

\subsection{Logical AND Expression}
\begin{grammar}
	<logical_and_expression> ::= <equality_expression>
		\alt <logical_and_expression> \&\& <equality_expression>
\end{grammar}
\begin{enumerate}
	\item The logical and operator (\&\&) is left associative and returns true if both its operands are not equal to false.
\end{enumerate}

\subsection{Logical OR Expression}
\begin{grammar}
	<logical_or_expression> ::= <logical_and_expression>
		\alt <logical_or_expression> || <logical_and_expression>
\end{grammar}
\begin{enumerate}
	\item The logical OR operator (||) is left associative and returns true if either of its operands are not equal to false.
\end{enumerate}

\subsection{Assignment Expressions}
\begin{grammar}
	<assignment_expression> ::= <logical_or_expression>
		\alt <unary_expression> = <assignment_expression>
\end{grammar}
\begin{enumerate}
	\item The assignment operator (=) is left associative.
\end{enumerate}


\subsection{Assignment Lists}
\begin{grammar}
	<assignment_list> ::= <assignment_expression>
		\alt <assignment_list> ::= <assignment_list> , <assignment_expression> 
\end{grammar}
\begin{enumerate}
	\item Assignment lists consist of multiple assignment statements separated by commas.
\end{enumerate}

\subsection{Declarations}
\begin{grammar}
	<declaration> ::=  let <storage_class> <identifier> : <type_name> = <postfix_expression>
		\alt var <storage_class> <identifier> : <type_name> = <postfix_expression>
		\alt <declaration> <array>
	
	<storage_class> ::= mutable
		\alt const
	
	<type_name> ::= void
		\alt unit
		\alt bool
		\alt int
		\alt float
		\alt <type_name> <array>
		
	<array> ::= [ <int_list> ]
		\alt [ <array> ]
	
	<int_list> ::= <integer>
		\alt <int_list> , <integer>
\end{grammar}
\begin{enumerate}
	\item Declarations of a variable specify a type for each identifier and a value to be assigned to the identifier.
	\item Declarations do not always allocate memory to be associated with the identifier.
\end{enumerate}

\subsection{Function Declaration}
\begin{grammar}
	<function_declaration> ::= fun <identifier> ( <params_list> ) : <type_name>
	
	<params_list> ::= < > 
		\alt <identifier> : <type_name> 
		\alt <params_list> , <identifier> : <type_name>
\end{grammar}
\begin{enumerate}
	\item Function declarations consist of the keyword fun followed by an identifier and a list of parameters enclosed in parentheses.
	\item The list of arguments is followed by a colon and a type name which represents the return type for the function.
	\item The arguments list is specified as a comma-separated list of identifier, type pairs.
\end{enumerate}
