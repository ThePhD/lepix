\section{Lexical Definitions and Conventions}
% defines the various names of the tokens used and how they behave
A program consists of one or more translation units, which are translated in two phases, namely the preprocessing step and the lexing step. The preprocessing step entails carrying out directives which begin with \# in a C-like style. The lexing step reduces the program to a sequence of tokens.

\subsection{Tokens}
\begin{enumerate}
	\item Tokens belong to _ categories. These are whitespace, keywords, operators, integer literals, floating point literals, string literals, identifiers, and brackets.
	\item Whitespace tokens are used to separate other tokens and are ignored in any case where they do not occur between other non-whitespace tokens.
\end{enumerate}

\subsection{Comments}
\begin{enumerate}
	\item Comments come in two flavors: single-line and multi-line.
	\item Single line comment begin with // and continue until the next newline character is found. Multi-line comments begin with /* and end with */. They are nested.
	\item Comments are treated as whitespace tokens, but for various purposes may still appear between other whitespace tokens in a program's token stream.
\end{enumerate}

\subsection{Identifiers}
\begin{enumerate}
	\item Identifiers are composed of letters, numbers and the underscore character (_) but must begin with a letter. Identifiers beginning with underscores and numbers will be reserved for use within the implementation of the language.
\end{enumerate}

\subsection{Keywords}
\begin{enumerate}
	\item A set of identifiers has been reserved for use as keywords and cannot be used in other cases. The list of keywords is in the table below.
\end{enumerate}

\begin{center}
\begin{tabular}{ c c c c } 
 int & float & void & bool \\
 unit & char & codepoint & string \\
 vector & matrix & vector & vec \\
 var & let & if & else \\
 for & while & by & to \\
 return & true & false & mutable\\
 const & fun & struct & maybe\\
 protected & public & private & shared\\
 as & of & parallel & atomic\\
\end{tabular}
\end{center}

\subsection{Literals}
\begin{enumerate}
	\item Literals are of three types: integer literals, floating literals, and string literals, as detailed in \ref{ssec:Kinds of Literals}. All of them use the following definitions for their digits:
	\begin{grammar}
		<decimal-digit> ::= one of\\
			0 1 2 3 4 5 6 7 8 9
			
		<hexidecimal-digit> ::= one of\\
			0 1 2 3 4 5 6 7 8 9\\
			A B C D E F\\
			a b c d e f
			
		<binary-digit> ::= one of\\
			0 1
			
		<octal-digit> ::= one of\\
			0 1 2 3 4 5 6 7
					
		<n-digit> ::= one of\\
			0 1 2 3 4 5 6 7 8 9\\
			A B C D E F G H I J K L M N O P Q R S T U V W X Y Z\\
			a b c d e f g h i j k l m n o p q r s t u v w x y z\\
			\lit{_}
			
		<decimal-digit-sequence> ::= <> \alt <decimal-digit> <decimal-digit-sequence>
		
		<binary-digit-sequence> ::= <> \alt <binary-digit> <binary-digit-sequence>
		
		<octal-digit-sequence> ::= <> \alt <octal-digit> <octal-digit-sequence>
	
		<hexidecimal-digit-sequence> ::= <> \alt <hexidecimal-digit> <hexidecimal-digit-sequence>
		
		<n-digit-sequence> ::= <> \alt <n-digit> <n-digit-sequence>
	\end{grammar}
	\item Integer literals consist of sequences of digits are always interpreted as decimal numbers. They can be represented by the following lexical compositions:

	\begin{grammar}
		<integer-literal> ::= 
			<decimal-literal>
			\alt <binary-literal>
			\alt <octal-literal>
			\alt <hexidecimal-literal>
			\alt <n-digit-literal>
			
		<decimal-literal> ::=
			<decimal-digit-sequence>
	
		<binary-literal> ::=
			0b <binary-digit-sequence>
			\alt 0B <binary-digit-sequence>
		
		<octal-literal> ::=
			0c <octal-digit-sequence>
			\alt 0C <octal-digit-sequence>
		
		<hexidecimal-literal> ::=
			0x <hexidecimal-digit-sequence>
			\alt 0X <hexidecimal-digit-sequence>
			
		<n-digit-literal> ::=
			0n <n-digit-sequence> `#'
			\alt 0N <n-digit-sequence>
	\end{grammar}

	\item Floating point literals can be specified using digits and a decimal points or in scientific notation. The following regular expression represents the set of acceptable floating-point constants.
	\begin{grammar}
		<e-part> ::=
			e <+ \textbar{} -> <integral-literal>
		
		<floating-literal> ::=
			<integral-literal>\lit*{$_{opt}$} . <integral-literal>\lit*{$_{opt}$} <e-part>\lit*{$_{opt}$}
			\alt <integral-literal> .\lit*{$_{opt}$} <integral-literal>\lit*{$_{opt}$} <e-part>
	\end{grammar}
	
	\item String literals are sections of quote-delimited items. They are defined as follows:
	\begin{grammar}
		<single-quote> ::= "\'"
		
		<double-quote> ::= "\""
		
		<raw-specifier> ::= R\lit*{$_{opt}$}
		
		<character> ::= <escape-character>
			<source-character>
		
		<character-sequence> ::= <>
		\alt <character> <character-sequence>
		
		<string-literal> ::=
		<raw-specifier> <double-quote> <character-sequence> <double-quote>
		\alt <raw-specifier> <single-quote> <character-sequence> <single-quote>
	\end{grammar}
	
\end{enumerate}
