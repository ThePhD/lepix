\section{Grammar Listing}

\begin{grammar}
<primary_expression> ::= <identifier> 
	\alt <integer-constant>  
	\alt <float-constant> 
	\alt (expression)

<postfix_expression> ::= <primary_expression> 
	\alt <postfix_expresion> ( argument_list )
	\alt <postfix_expression> [ expression ]
	\alt <postfix_expression> . identifier

<argument_list> ::= <>
	\alt <argument_list> , <postfix_expression>

<unary_operator> ::= \~
	\alt !
	\alt -
	\alt *

<unary_expression> ::= <unary_operator> <postfix_expression>

<cast_expression> ::= <unary_expression>
	\alt <unary_expression> as <type_name>

<multiplicative_expression> ::= <cast_expression>
	\alt <multiplicative_expression> * <cast_expression>
	\alt <multiplicative_expression> / <cast_expression>
	\alt <multiplicative_expression> \% <cast_expression>

<additive_expression> ::= <multiplicative_expression>
	\alt <additive_expression> + <cast_expression>
	\alt <additive_expression> - <cast_expression>

<relational_expression> ::= <additive_expression>
	\alt <relational_expression> \textless{} <additive_expression>
	\alt <relational_expression> \textless{}= <additive_expression>
	\alt <relational_expression> \textgreater{} <additive_expression>
	\alt <relational_expression> \textgreater{}= <additive_expression>

<equality_expression> ::= <relational_expression>
	\alt <equality_expression> != <relational_expression>
	\alt <equality_expression> == <relational_expression>

<logical_and_expression> ::= <equality_expression>
	\alt <logical_and_expression> \&\& <equality_expression>

<logical_or_expression> ::= <logical_and_expression>
	\alt <logical_or_expression> || <logical_and_expression>

<assignment_expression> ::= <logical_or_expression>
	\alt <unary_expression> = <assignment_expression>

<assignment_list> ::= <assignment_expression>
	\alt <assignment_list> ::= <assignment_list> , <assignment_expression> 

<declaration> ::=  var <storage_class> <identifier> : <type_name> = <postfix_expression>

<type_name> ::= bool
	\alt int
	\alt float
	\alt <type_name> <array>

<array> ::= [ <int_list> ]
	\alt [ <array> ]

<int_list> ::= <integer>
	\alt <int_list> , <integer>

<function_declaration> ::= fun <identifier> ( <params_list> ) : <type_name>

<params_list> ::= < > 
	\alt <identifier> : <type_name> 
	\alt <params_list> , <identifier> : <type_name>

<statement> ::= <expression_statement>
	\alt <branch_statement>
	\alt <compound_statement>
	\alt <iteration_statement>
	\alt <return_statement>

<expression_statement> ::= < >
	\alt <expression> ;

<block> ::= \{ <compound_statement> \}
	\alt \{ <block> <compound_statement>\}

<compound_statement> ::= <declaration>
	\alt <statement>
	\alt <compound_statement> ; <declaration>
	\alt <compound_statement> ; <statement>

<parallel_block> ::= parallel ( <parallel_control_variables> ) <block>

<branch_statement> ::= if ( <expression> ) <statement> fi
	\alt if ( <expression> ) <statement> else <statement> fi

<branch_statement> ::= if ( <expression> ) <statement> fi
	\alt if ( <expression> ) <statement> else <statement> fi

<loop_statement> ::= while ( <expression> ) <statement>
	\alt for ( <identifier> = <expression> to <expression> ) <statement>
	\alt for ( <assignment_expression> = <expression> to <expression> by <expression> ) <statement>
	\alt for ( <expression>; <expression>; expression> ) <statement>

<identifier_list> ::= <identifier>
	\alt <identifier_list> , <identifier>

<jump_statement> ::= break <integer-literal>\lit*{$_{opt}$}
	\alt continue

<return_statement> ::= return 
	\alt return <expression>
\end{grammar}






















