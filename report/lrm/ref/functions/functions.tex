\section{Functions and Function Declarations}
% How to declare a function, its return type, and its arguments

Functions are independent code that perform a particular task and can be reused across programs. They can appear in any order and in one or many source files, but cannot be split among source files.

Function declarations tell the compiler how a function should be called, while function definitions define what the function does. 

\subsection{Function Definitions}\label{ssec:Function Definitions}
\begin{enumerate}
\begin{lstlisting}[numbers=none]
fun <identifier> ([<parameter_declarations>]) : <return_type> { 
	<function_body> 
	[return <expression>;] 
}
\end{lstlisting}
	\item All function definitions in \lepix{} are of the above form where they begin with the keyword \lstinline|fun|, followed by the identifier, a list of optional parameter declarations enclosed in parentheses, optionally the \lstinline|return| type, and the function body with an optional \lstinline|return| statement.
	\item \lstinline|return| types can be variable types or \lstinline|void|. 
	\item Functions that return \lstinline|void| can either omit the \lstinline|return| statement or leave it in or return the value \lstinline|unit|:
\begin{lstlisting}[numbers=none]
fun zero ( &arr:int[] ) : void {
	for (var i : int = 0 to arr.length) {
		arr[i] = 0;
	}
}
\end{lstlisting}
\begin{lstlisting}[numbers=none]
fun zero ( &arr:int[] ) : void {
	for (var i : int = 0 to arr.length) {
		arr[i] = 0;
	}
	return;
}
\end{lstlisting}
	\item Functions that return any other variable type must include a \lstinline|return| statement and the expression in the \lstinline|return| statement must evaluate to the same type as the \lstinline|return| type or be convertible to the \lstinline|return| type:
\begin{lstlisting}[numbers=none]
fun add ( arg1:float, arg2:float ) : float {
	return arg1 + arg2;
}
\end{lstlisting}
	\item In the function \lstinline|add|, \lstinline|arg1| and \lstinline|arg2| are passed by value. In the function zero, arr is passed by reference.
	\item Function input parameters can be passed by value, for all variable types, or by reference, only for arrays and array derived variable types. See \ref{ssec: Function Scope and Parameters} for more about passing by value and reference.
\end{enumerate}

\subsection{Function Declarations}\label{ssec:Function Declarations}
\begin{enumerate}
	\item All function declarations in \lepix{} are of the form
\begin{lstlisting}[numbers=none]
fun <identifier> ([<parameter_declarations>]) : <return_type>;
\end{lstlisting}
	\item The function declaration for the add function from 3.1.1 would be
\begin{lstlisting}[numbers=none]
fun add ( arg1:float, arg2:float ) : float;
\end{lstlisting}
	\item Function declarations are identical to function definitions except for the absence or presence of the code body.
	\item Function declarations are optional, but useful to include when functions are used across multiple translation units to ensure that functions are called appropriately.
\end{enumerate}

\subsection{Function Scope and Parameters}\label{ssec: Function Scope and Parameters}
\begin{enumerate}
	\item Variables are declared as usual within the body of a function. The variables declared within the body of a function exist only in the scope of the function and are discarded when they go out of scope.
	\item External variables are passed into functions as parameters. All variable types except arrays and array derived variable types are passed by value. Arrays and array derived variable types can be passed by both value and reference.
	\item Passing value copies the object, meaning changes are made to the copy within the function and not the original. Passing by reference gives a pointer to the original object to the function, meaning changes are to the original within the function.
	\item To pass by value to a function, use the variable name: \lstinline|add ( x, y );|
	\item To pass by reference to a function, use the symbol \& and the variable name, as in \lstinline|zero ( &arr );|.	
\end{enumerate}
