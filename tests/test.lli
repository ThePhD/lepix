; ModuleID = 'lepix'

@__ifmt = global [3 x i8] c"%d\00"
@__sfmt = global [3 x i8] c"%s\00"
@__ffmt = global [3 x i8] c"%f\00"
@str_lit = private unnamed_addr constant [2 x i8] c"\0A\00"
@str_lit.1 = private unnamed_addr constant [2 x i8] c"\0A\00"
@str_lit.2 = private unnamed_addr constant [2 x i8] c"\0A\00"
@n.s.global = global i32 8
@str_lit.3 = private unnamed_addr constant [6 x i8] c"bark!\00"
@n.s.stuff = global i8* getelementptr inbounds ([6 x i8], [6 x i8]* @str_lit.3, i32 0, i32 0)

declare i32 @printf(i8*, ...)

define void @"lib.print_n_!f32"(float %i) {
entry:
  %0 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @__ffmt, i32 0, i32 0), float %i)
  %1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @__sfmt, i32 0, i32 0), i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str_lit, i32 0, i32 0))
  ret void
}

define void @"lib.print_n_!i32"(i32 %i) {
entry:
  %0 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @__ifmt, i32 0, i32 0), i32 %i)
  %1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @__sfmt, i32 0, i32 0), i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str_lit.1, i32 0, i32 0))
  ret void
}

define void @"lib.print_n_!s"(i8* %i) {
entry:
  %0 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @__sfmt, i32 0, i32 0), i8* %i)
  %1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @__sfmt, i32 0, i32 0), i8* getelementptr inbounds ([2 x i8], [2 x i8]* @str_lit.2, i32 0, i32 0))
  ret void
}

define i32 @main() {
entry:
  %local = alloca i32
  %svalue = alloca i32
  %tmp = load i32, i32* @n.s.global
  store i32 %tmp, i32* %local
  %tmp.call = call i32 @"s_!i32"()
  store i32 %tmp.call, i32* %svalue
  %tmp1 = load i32, i32* %local
  call void @"lib.print_n_!i32"(i32 %tmp1)
  %tmp2 = load i32, i32* %svalue
  call void @"lib.print_n_!i32"(i32 %tmp2)
  %tmp.call3 = call i32 @"s_!i32"(i32 2)
  call void @"lib.print_n_!i32"(i32 %tmp.call3)
  %tmp4 = load i32, i32* @n.s.global
  call void @"lib.print_n_!i32"(i32 %tmp4)
  %tmp5 = load i8*, i8** @n.s.stuff
  call void @"lib.print_n_!f32"(i8* %tmp5)
  ret i32 0
}

define i32 @"s_!i32"(i32 %x) {
entry:
  %tmp.bop = add i32 %x, 2
  ret i32 %tmp.bop
}

define i32 @s() {
entry:
  ret i32 2
}
