\chapter{The \lepix{} Language}


\section{Language}
The language itself is meant to follow loosely from imperative C, but it subject to change as we refine our desired set of primitives and base operations. What follows is a loose definition of the primitive types, operations we would like to implement to get a baseline for the language, and how would would like to put those together syntactically and grammatically. All of these definitions will be mostly informal.

The goal of \lepix{} is to provide a strongly and statically typed language by which to perform image manipulation easily. The hope is that powerful algorithms can be expressed in the language by providing a useful set of basic types, including the concept of a pixel and a natively slice-able matrix type that will serve as the basis for an image.

\begin{itemize}
	\item Primitive Data Type: the core types defined by the language itself and given a set of supportable operations
	\item Built-ins: some of the built-in functions to help users  
	\item Function Definitions: how to define a function in the language and use it
	\item Operators: which operators put into the language and operate on the primitive types
\end{itemize}

\subsection{User Defined Types}
Support for user-defined types is planned, but will be a stretch goal (\ref{sec:stretch user defined types}). We want to support having user-defined types that can be used everywhere, and for it to be able to overload the conceivable set of all operations.

\subsection{Syntax}
This is a basic guide to the syntax of the language. We are striving to develop a C-Like imperative language. It will follow many of the C conventions, but with some differences that we think will better fit the domain we are striving to work within. As we do not have a formal grammer just yet, we will present potential programs that we wish to allow to generate appropriate code. You can find these example programs in \ref{sec:examples}. Below are some quick points about the \lepix{} language.

\paragraph{Namespacing}
As a stretch goal, \lepix{} will attempt to support namespacing, to avoid record collision problems as present in OCaml (without the use of modules) and to formalize the good practice of of prepending the short name of the module / library to all functions in C code. Other languages have explicit support. \lepix{} will attempt to encourage code sharing and reuse by including the use of namespacing.

\paragraph{Keywords}
The following words will be reserved for use with the language: \lstinline|namespace, struct, class, typename, typedef, for, while, break, if, elseif, else, void, unit, int, float, uint, pixel, image, vec, vector, mat, matrix|. In addition, all identifiers containing \verb|__| (two underscores) are reserved for the use of the compiler and the standard library.

The standard library reserves the usage of the namespace \lstinline|lib|. The language will place intrinsics and built-ins within the \lstinline|lpx| namespace.

\paragraph{Function Definitions}
\label{par:function-definitions}
Typical function definitions will follow a usual C-style syntax. An example in pseudo-lexer code:
\lstinputlisting{code/func-def.lex}

Ideally, we would like the order of function definition not to matter, so long as it appears \emph{somewhere} in the whole source code listing. Early versions of the \lepix{} compiler might require definition before use, for sanity purposes.

As a stretch goal, there are plans for lambda functions (anonymous function values) to be generated by a much more terse syntax.

\paragraph{Control Flow}
Control flow will follow a C-style syntax as well. An example in pseudo-lexer code:
\lstinputlisting{code/flow-control.lex}

\paragraph{Operations}
The \lepix{} language will support most of the basic mathematical operators. Other operators will be provided VIA functions. These include:

\begin{itemize}
	\item Mathematical - \verb|plus (+), minus (-), multiply (*),|\\
	\verb|divide (/), modulus (%), power of (**)|
	\item Logical - \verb+and (&&), or (||), less than (<),+\\
	\verb+greater than (>), equal to (==), not equal to (!=)+\\
	\verb+negate (!)+
\end{itemize}

Some of these will use both the symbol and the name, such as "not" for negation. Support for bitwise operations, such as left shift and right shift as well as bitwise and / bitwise or, will come as a stretch goal, depending on whether we can handle these basics. Ternary conditionals may also prove useful, but will not be immediately supported.

\paragraph{Comments}
Single-line comments will begin with \lstinline|//|. Multi-line and \emph{nestable} comments will begin with \lstinline|/**/| will be supported as well.

\subsection{Built-ins}
Some useful built-in functions that will be provided with the language:

\begin{itemize}
	\item Trigonometric functions: \lstinline|lib.sin|, \lstinline|lib.cos|, \lstinline|lib.tan|, \lstinline|lib.asin|, \lstinline|lib.acos|, \lstinline|lib.atan|, \lstinline|lib.atan2|
	\item Power Functions: \lstinline|lib.sqrt|, \lstinline|lib.cbrt|, \lstinline|lib.pow|
	\item Exponential Functions: \lstinline|lib.expe|, \lstinline|lib.exp2|, \lstinline|lib.loge|, \lstinline|lib.log2|, \lstinline|lib.log10|
\end{itemize}

All degree arguments will come in radians. Other functions that operate on built-in types will be provided as library functions, to allow for replacement if necessary.

\subsection{Primitive Types}
Primitives are integral types and multi-dimensional array types. Vectors, Matrices, and Pixels are all subsets of N-dimensional array types. String will be presented as a built-in type, but may be implemented either as a built-in or just an always-included library type. The purpose of string will be specifically to handle reading in and writing out from the file system, as that is the only way to handle such a case. See \ref{tab:primitives} for details.

\input{primitives}